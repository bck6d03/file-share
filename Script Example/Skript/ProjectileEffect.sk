#相關sk: ScoreboardTag_Value.sk
#使用plugin: skript, SkBee, SkQuery, skript-reflect

#sk reload ProjectileEffect.sk
#研究各種和投射物相關的實用效果



#測試用工具
command /projectileTest:
	description: 給予玩家測試物品
	executable by: players
	trigger:
		set {_e} to GetTarget(zombie and wolf, player, 16)
		send "%{_e}%" to player
		give player bow named "反射弓"



#生成帶有投射物相關nbt的工具
function projectileTool(i:item, noGravity:integer, rebound:integer, :integer) :: item:
	set {_nbt} to nbt compound of {_i}
	add nbt compound of "{noGravity:0,rebound:0,}" to {_nbt}
	return {_i}



#CMotion: 自定位移向量
#noGravity: 0=沒有效果, 1=移除投射物重力,只使用CMotion控制移動方向
#rebound: 撞牆反彈次數
#track;type: 追蹤模式 0=無 , 1=只追蹤目標 , 2=自動鎖定追蹤距離內的實體
#track;range: 追蹤距離
#track;angle: 追蹤強度
#Ｘtrack;target:[] 追蹤目標的uuid
#Ｘtrack;autotargets:[] 自動鎖定的實體種類

#stop: 設為1使CMotion loop 中止

on shoot:
	#測試投射物，使箭變成直線飛行
	if event-projectile is arrow:
		if shooter's tool is bow named "反射弓":
			set {_nbt} to nbt compound of event-projectile
			#增加自定nbt CMotion rebound
			add nbt compound of "{custom:{CMotion:[0.0,0.0,0.0],noGravity:1,rebound:5,stop:0}}" to {_nbt}
			add nbt compound of "{custom:{track:{type:1,range:12,angle:0.5}}}" to {_nbt}
			#提取移動向量
			set {_motion::*} to double list tag "Motion" of {_nbt}
	#		set {_vstartmotion} to vector({_motion::1}, {_motion::2}, {_motion::3})
			set {_vmotion} to vector({_motion::1}, {_motion::2}, {_motion::3})
			set double list tag "custom;CMotion" of {_nbt} to {_motion::*}
			
			#追蹤相關數值
			set {_track.type} to 1
			set {_track.range} to 12
			set {_track.angle} to 0.5
			#{_track.target}

			loop 1200 times:
				set {_nbt} to nbt compound of event-projectile	
				if tag "custom;stop" of {_nbt} is 1:
					stop
				
				#追蹤處理
				if tag "custom;track;type" of {_nbt} is 1:
					set {_projloc} to event-projectile's location
					if {_target} is not set:
						set {_target} to GetTarget((zombie and wolf), {_projloc}, {_track.range})
					if {_target} is set:
						set {_projv} to vector of {_projloc}
						set {_tarv} to vector of {_target}'s location
						
						set {_motion::*} to double list tag "custom;CMotion" of {_nbt}
						set {_vstart} to vector({_motion::1}, {_motion::2}, {_motion::3})
						set {_vend} to ({_tarv} -- {_projv}) normalized
						
						set {_v} to VectorSlerp({_vstart}, {_vend}, {_track.angle})
						set {_trackmoction::*} to x of {_v} , y of {_v} and z of {_v}
						set double list tag "custom;CMotion" of {_nbt} to {_trackmoction::*}
					
				#提取 CMotion，更新Motion
				if tag "custom;noGravity" of {_nbt} is 1:
					set {_vmotion::*} to double list tag "custom;CMotion" of {_nbt}
					set double list tag "Motion" of {_nbt} to {_vmotion::*}
				wait 1 tick
	
	
	
	
	
	




#測試投射物擊中方塊反彈
on projectile hit:
	if event-projectile is arrow:
		set {_nbt} to nbt compound of event-projectile
		set {_rebound} to int tag "custom;rebound" of {_nbt} 
		if {_rebound} is more than 1:
			if victim is set:
				set tag "custom;stop" of {_nbt} to 1
				
			remove 1 from {_rebound}
			set tag "custom;rebound" of {_nbt} to {_rebound}
			
			if event.getHitBlockFace() is set:
				set {_hitBlockFace} to event.getHitBlockFace()
			
			set {_pi} to 3.14159265359
			
			#提取移動向量
			set {_motion::*} to double list tag "Motion" of {_nbt}
			set {_vmotion} to vector({_motion::1}, {_motion::2}, {_motion::3})
			set {_inputVector} to {_vmotion}
			#提取投射物所在的block位置　
			set {_loc.proj} to event-projectile's location
			set {_loc.projold} to {_loc.proj} ~ vector({_motion::1} * -1, {_motion::2} * -1, {_motion::3} * -1)
			set {_loc.projnew} to {_loc.proj} ~ {_vmotion}
			
			set {_b.proj} to block at {_loc.proj}
			set {_bloc.proj} to {_b.proj}'s location
			#提取命中的block位置
			set {_bloc.hit} to event-block's location
			
			set {_bv.proj} to vector of {_bloc.proj}
			set {_bv.hit} to  vector of {_bloc.hit}
			
			#面向轉vector
			if "%{_hitBlockFace}%" is "up":
				set {_vector90} to vector 0, 1, 0
			if "%{_hitBlockFace}%" is "down":
				set {_vector90} to vector 0, -1, 0
			if "%{_hitBlockFace}%" is "east":
				set {_vector90} to vector 1, 0, 0
			if "%{_hitBlockFace}%" is "west":
				set {_vector90} to vector -1, 0, 0
			if "%{_hitBlockFace}%" is "south":
				set {_vector90} to vector 0, 0, 1
			if "%{_hitBlockFace}%" is "north":
				set {_vector90} to vector 0, 0, -1
				
			set {_vector90} to normalized {_vector90} #用來做鏡像的向量
			set {_vector90rev} to {_vector90} ** vector(-1,-1,-1)
#			send "%{_vector90}% %{_vmotion}%" to shooter
			
			set {_angle} to angle between {_inputVector} and {_vector90rev} #{_inputVector}.angle({_vector90}) * 180/{_pi}
			set {_length} to 2 * vector length of {_inputVector}
			set {_length} to {_length} * cos({_angle})
			set {_vector90l} to {_vector90} ** vector({_length},{_length},{_length})
#			set {_vector90} to {_vector90} normalized ** {_length}
#			send "%{_angle}% %{_inputVector}% %{_vector90l}% %{_length}%" to shooter
			
			#投射物以block位置為中心的鏡像位置
			set {_mirror1} to MirroredLocation({_loc.proj} , {_loc.projnew})
			#set {_mirror1} to MirroredLocation({_loc.projold} , {_loc.proj})
			set {_mirror2} to {_mirror1} ~ {_vector90l}      #Offset a location by a vector : %location% ~ %vector%
			set {_VectorRebound} to vector x-coordinate of {_mirror2} - x-coordinate of {_loc.projnew}, y-coordinate of {_mirror2} - y-coordinate of {_loc.projnew}, z-coordinate of {_mirror2} - z-coordinate of {_loc.projnew}
			
			set {_newmotion::*} to x of {_VectorRebound} , y of {_VectorRebound} and z of {_VectorRebound}
			
			wait 1 tick
#			teleport event-projectile to event-projectile ~ {_vector90}
			teleport event-projectile to event-projectile ~ ({_vector90} ** vector(0.5,0.5,0.5))
			if tag "custom;noGravity" of {_nbt} is 1:
				set double list tag "custom;CMotion" of {_nbt} to {_newmotion::*}
			else:
				set double list tag "Motion" of {_nbt} to {_newmotion::*}







#計算以loc2為中心，loc1的鏡像位置
function MirroredLocation(loc1:location, loc2:location) :: location:
	set {_dis} to distance between {_loc1} and {_loc2}
	set {_vloc1} to vector of {_loc1}
	set {_vloc2} to vector of {_loc2}
	
	set {_v} to {_vloc2} -- {_vloc1}
	set {_v} to normalized {_v}
	set {_vdis} to vector({_dis} * 2, {_dis} * 2, {_dis} * 2)
	set {_voffset} to {_v} ** {_vdis}
	
	set {_loc1m} to {_loc1} ~ {_voffset}
	return {_loc1m}



function VectorSlerp(start:vector, end:vector, percent:number) :: vector:
	set {_dot} to {_start} dot {_end}
	#set {_dot} to Clamp({_dot}, -1.0, 1.0)
	set {_theta} to acos({_dot}) * {_percent}
	set {_RelativeVec} to {_end} -- ({_start} ** vector({_dot},{_dot},{_dot}))
	set {_RelativeVec} to {_RelativeVec} normalized
	
	set {_costheta} to cos({_theta})
	set {_sintheta} to sin({_theta})
	set {_A} to {_start} ** vector({_costheta},{_costheta},{_costheta})
	set {_B} to {_RelativeVec} ** vector({_sintheta},{_sintheta},{_sintheta})
	return {_A} ++ {_B}



function GetTarget(etypes:objects, loc:location, range:number) :: entity:
#	broadcast "%{_etypes::*}%"
	set {_target::*} to all entities of types {_etypes::*} in radius {_range} around {_loc}
	return {_target::1}

#sk reload ProjectileEffect.sk


